import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _typeof from "@babel/runtime/helpers/typeof";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { useState } from 'react';
import { objectReduce } from 'fast-loops';

function validateField(validation, value) {
  return objectReduce(validation, function (error, validate, message) {
    // early return to skip the rest once the first validation failed
    if (error) {
      return error;
    }

    if (validate instanceof RegExp) {
      if (typeof value === 'string' && value.match(validate) === null) {
        return message;
      }
    } else if (!validate(value)) {
      return message;
    }
  }, undefined);
}

export function useField(_ref) {
  var _props;

  var name = _ref.name,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? '' : _ref$value,
      _ref$touched = _ref.touched,
      touched = _ref$touched === void 0 ? false : _ref$touched,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$required = _ref.required,
      required = _ref$required === void 0 ? false : _ref$required,
      _ref$loading = _ref.loading,
      loading = _ref$loading === void 0 ? false : _ref$loading,
      showValidationOn = _ref.showValidationOn,
      _ref$requiredErrorMes = _ref.requiredErrorMessage,
      requiredErrorMessage = _ref$requiredErrorMes === void 0 ? 'This field is required.' : _ref$requiredErrorMes,
      _ref$validation = _ref.validation,
      validation = _ref$validation === void 0 ? {} : _ref$validation;

  var type = _typeof(value); // add a special validation for required fields where the browser doesn't auto catch


  if (required) {
    validation[requiredErrorMessage] = function (value) {
      return type === 'string' ? value.length > 0 : type === 'boolean' ? value : true;
    };
  }

  var errorMessage = validateField(validation, value);
  var initial = {
    value: value,
    errorMessage: errorMessage,
    isLoading: loading,
    isDisabled: disabled,
    isTouched: touched,
    isRequired: required,
    isValid: !errorMessage && !loading
  };

  var _useState = useState(initial),
      _useState2 = _slicedToArray(_useState, 2),
      field = _useState2[0],
      setField = _useState2[1];

  var touch = function touch() {
    return setField(function (field) {
      return _objectSpread(_objectSpread({}, field), {}, {
        isTouched: true
      });
    });
  };

  var untouch = function untouch() {
    return setField(function (field) {
      return _objectSpread(_objectSpread({}, field), {}, {
        isTouched: false
      });
    });
  };

  var update = function update(values) {
    return setField(function (field) {
      return _objectSpread(_objectSpread({}, field), values);
    });
  };

  function onChange(event) {
    var newValue = type === 'boolean' ? event.target.checked : event.target.value;
    var dirty = newValue !== value;
    var errorMessage = validateField(validation, newValue);
    setField(function (field) {
      return _objectSpread(_objectSpread({}, field), {}, {
        value: newValue,
        errorMessage: errorMessage,
        isTouched: showValidationOn === 'change' ? dirty : field.isTouched,
        isValid: !errorMessage && !field.isLoading
      });
    });
  }

  var props = (_props = {
    name: name
  }, _defineProperty(_props, type === 'boolean' ? 'checked' : 'value', field.value), _defineProperty(_props, "loading", field.isLoading), _defineProperty(_props, "disabled", field.isDisabled), _defineProperty(_props, "required", field.isRequired), _defineProperty(_props, "errorMessage", field.isTouched ? field.errorMessage : undefined), _defineProperty(_props, "isValid", field.isTouched ? !field.errorMessage : true), _defineProperty(_props, "onChange", onChange), _props); // by default, we always hide validation errors once the field is focused again

  props.onFocus = untouch;

  if (showValidationOn === 'blur') {
    props.onBlur = touch;
  }

  return _objectSpread(_objectSpread({}, field), {}, {
    initial: initial,
    name: name,
    props: props,
    update: update,
    touch: touch,
    untouch: untouch
  });
}