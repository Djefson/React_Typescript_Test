"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RadioGroup = RadioGroup;
exports.RadioContext = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactFela = require("react-fela");

var _propTypes = require("prop-types");

var _view = require("../view");

var _block = require("../block");

var _message = require("../message");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var labelStyle = function labelStyle(_ref) {
  var isValid = _ref.isValid,
      theme = _ref.theme;
  return {
    color: isValid ? theme.color.foreground.secondary : theme.color.foreground.alert,
    fontSize: 16,
    letterSpacing: '0.02em',
    fontFamily: theme.fontTypes.NOVUM,
    fontWeight: 300
  };
};

var RadioContext = /*#__PURE__*/(0, _react.createContext)({});
exports.RadioContext = RadioContext;

function RadioGroup(_ref2) {
  var legend = _ref2.legend,
      name = _ref2.name,
      _ref2$isValid = _ref2.isValid,
      isValid = _ref2$isValid === void 0 ? true : _ref2$isValid,
      value = _ref2.value,
      onChange = _ref2.onChange,
      errorMessage = _ref2.errorMessage,
      description = _ref2.description,
      children = _ref2.children;

  var _useFela = (0, _reactFela.useFela)(),
      theme = _useFela.theme;

  var styleProps = {
    isValid: isValid,
    theme: theme
  };
  var context = {
    name: name,
    isValid: isValid,
    value: value,
    onChange: onChange
  };

  var messages = /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, !errorMessage ? null : /*#__PURE__*/_react.default.createElement(_message.Message, {
    type: "error"
  }, errorMessage), !description ? null : /*#__PURE__*/_react.default.createElement(_message.Message, null, description));

  return /*#__PURE__*/_react.default.createElement(_view.View, {
    spacing: 0.5
  }, /*#__PURE__*/_react.default.createElement(_block.Block, {
    as: "legend",
    extend: labelStyle(styleProps)
  }, legend), /*#__PURE__*/_react.default.createElement(RadioContext.Provider, {
    value: context
  }, children), messages);
}

RadioGroup.propTypes = {
  name: _propTypes.string,

  /** Renders a legend.  */
  legend: _propTypes.string,

  /** Renders a description text underneath the input.  */
  description: _propTypes.string,

  /** Renders a red error message for validation underneath the input.  */
  errorMessage: _propTypes.string,

  /** onChange handler. Triggers on every keyboard and generally
   * is here where you change the value of the `value` property  */
  onChange: _propTypes.func.isRequired,

  /** Value of the textInput. This should be stored in the
   * state of the parent component  */
  value: _propTypes.string.isRequired,

  /** Renders the input as valid or invalid */
  isValid: _propTypes.bool,

  /** A JSX node */
  children: _propTypes.node
};